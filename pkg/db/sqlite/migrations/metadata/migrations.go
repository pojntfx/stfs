package metadata

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"strings"
)

func bindata_read(data []byte, name string) ([]byte, error) {
	gz, err := gzip.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	var buf bytes.Buffer
	_, err = io.Copy(&buf, gz)
	gz.Close()

	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	return buf.Bytes(), nil
}

var _db_sqlite_migrations_metadata_1637447083_sql = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xa4\x56\xc1\x72\x1b\x37\x0c\x3d\xd7\x5f\x81\xc9\x25\xf6\x54\xab\x73\xa7\x99\x1e\xdc\xb8\x71\x3d\x63\x3b\x19\xd9\xaa\x73\xa5\x96\xd8\x5d\x56\x5c\x82\x05\xb9\x92\x37\x5f\xdf\x01\xb9\x54\x64\xa9\x52\xa7\xd3\x93\xa8\x25\xf0\x88\x07\x02\x0f\xac\x2a\xf8\xb1\x37\x2d\xab\x88\xb0\xf4\x17\x35\xa3\xac\xa2\x5a\x59\x84\x0e\x95\x46\x0e\x70\x79\x01\x00\x50\x55\xb0\xc0\x9a\x58\x03\x35\x10\x3b\x13\xa6\x7d\x20\x07\xb1\x13\x1f\x8f\xc9\x90\xb3\x95\x71\x11\x5b\x64\x70\x14\xc1\x0d\xd6\xce\x0a\xca\xaf\x96\xea\xf5\x21\x88\xc9\x20\xd9\x37\x59\xae\x92\xd9\x49\x94\xe7\xd1\x63\x63\x55\x0b\x26\xe4\xe3\x47\x8f\x02\x3a\xe1\xa1\x8b\x3c\xce\x77\xc6\x1d\xc2\x37\x64\x82\x8d\xb2\x03\x8a\x8b\x1a\x22\xf5\x2a\x9a\x5a\x59\x3b\x82\x67\xea\x29\xa2\x86\x48\x80\x26\x76\xc8\x09\x7f\x81\x2d\x50\x5e\xde\x18\x2e\x60\x1a\x3d\x3a\x6d\x5c\x5b\x98\x7b\xc6\x80\xae\x4e\xc7\x2b\x88\xac\x8c\x95\xdd\x60\x55\xe8\x84\xd8\xa3\xea\x31\x87\x12\x77\x41\x9f\xa2\x25\xb6\x82\xd3\x18\x8b\x99\x44\xda\x71\xf2\x39\xe2\x6b\xdc\x79\x80\x67\xd3\x2b\x1e\x61\x8d\xe3\xf7\xa4\x28\x6e\x31\x66\x6b\x6a\xc0\x1a\xb7\x86\xcb\x8d\xb2\x46\x43\x33\x11\xb9\x97\x6f\xd3\xfa\x69\xec\xc5\xe4\x2a\xb9\xcb\xea\xf8\x98\x1d\xf4\x3d\xb5\x92\xac\x1c\x58\x30\xdf\x50\x98\xad\xc6\x88\x21\x59\x4c\x5f\x4e\xb0\xfa\x82\xdc\x9b\x10\x0c\x39\x50\x4e\x43\x4f\x1a\x61\x65\x62\x76\x4d\xff\x4e\xba\x2e\x03\x32\xdc\xdd\x08\x1d\xda\x3a\xcc\xb7\x30\x98\x33\xf5\x75\xcb\x34\xf8\x23\x97\xf6\x9c\x4b\x3a\xa4\x64\x6d\xef\x98\x33\xf9\xc8\xa7\x1c\xfb\xb4\x67\x7c\xee\x9a\x54\x2f\x9f\x88\x7b\x15\xa5\x0a\x07\x17\x3c\xd6\xa6\x31\xa8\x67\xb2\xe5\xe0\x85\x4d\x44\x9e\xa7\x9f\xdf\x73\x29\x33\x0d\x4e\x07\x78\x20\xfd\x6c\x7a\x2c\x58\x91\x12\x96\x43\xc5\x18\x22\x04\xac\xc9\xe9\x94\x5d\xd3\x3a\x62\xcc\x5d\x71\x5d\xd7\x18\x82\xf8\xa5\xad\x8f\x9d\x72\x2d\xa6\xbf\x8d\x41\xab\x43\xe9\x90\x5d\x01\x11\x0c\xe1\x8d\x1b\xf1\x9e\xd7\x0c\x72\xbc\xe3\x3e\x0f\x15\xe0\xcb\xf5\x57\x31\xbc\x7d\x5c\xce\x0f\x90\xc2\xb0\xaa\xa6\xd8\x18\x03\xd9\x21\x1a\x72\x67\x60\x76\xfe\x0f\xa4\x4d\x63\x6a\x25\xf6\x10\x0b\xf1\x9e\xb4\xac\x41\x8b\x4a\x1d\xe5\x37\x87\x9d\xac\xe1\x92\xf1\xaf\xc1\x48\x1e\xa6\x86\xfe\x1e\x23\x84\xc1\x7b\xe2\x98\xeb\x5e\x25\xa7\x33\xa8\x99\xfe\x7f\x44\xad\x93\xd3\x19\xd4\x07\xf5\x27\x31\x68\xdc\x98\x1a\xc1\x0d\xfd\x0a\xf9\xb0\x55\x3f\x76\x8a\x4b\xab\x26\xd1\xcc\xd0\x1a\x37\x7d\x72\x3e\x59\xce\x0f\xc6\xfd\x0f\xec\xe4\x7c\xba\x95\xaf\xbf\xe6\x31\x10\x92\x8c\x42\xaf\xbc\x34\x80\xe4\x01\x5f\x23\x3a\x8d\xba\x68\x70\x16\xf3\xa3\x1a\x93\x66\xab\x34\x36\xc6\xa1\x2e\x36\x10\x3a\x1a\xac\x86\x4e\x6d\x50\x14\x2d\xe4\xf9\x80\xd0\x90\xb5\xb4\x15\x39\x6d\x88\xfb\x9f\x27\x8c\x1f\xfe\xf8\xed\xf1\xe6\xf3\x62\xbe\xc6\x71\x5b\xe6\x45\x55\xc1\x4b\x87\x8c\x90\xf7\x24\xba\x40\x3d\xa6\x16\x0d\x5e\xd5\x49\xb0\x94\xb5\x30\x78\x8f\x5c\xab\x80\xb3\xd4\x13\x13\x06\xf4\x6a\x2c\x38\x42\xba\x26\x17\xd5\x34\x95\xde\xff\xf2\x5e\x2e\x94\x55\x1d\x25\x93\x38\x6f\xe7\x33\x78\x77\xfb\xf9\xfe\xfa\xf1\x76\xee\xd7\xed\x7c\x83\x2c\xe2\xf6\xee\xea\xcd\xc4\x59\xe3\x98\x4e\xc8\x43\x67\x62\xb8\x92\x5a\x70\x15\xf6\x3e\x8e\xb0\x7c\xfe\x54\xfd\x04\x21\xb2\x71\xed\x51\x9e\x5e\x4e\xe8\x81\x09\x20\x53\x4b\x24\x43\xb2\x5e\x32\xa8\x91\xcd\x06\x35\x34\x4c\xbd\x44\x5d\x60\x28\xd5\x69\x6e\x77\x49\xc1\x84\x12\xd5\x3a\x4d\xae\x1a\x75\x9e\x5d\x9b\x5c\xcd\x8b\xfd\x4b\xf3\xea\xb5\xc0\xff\xb3\xa2\x4d\xbd\x5b\x54\x2c\x4c\x77\x96\x3e\x4e\x37\x18\x15\x4f\x05\x71\x24\x36\x32\xff\xe5\x9a\x30\xc2\x6a\x84\x45\x36\x7a\x94\x83\x94\x94\xd6\x0a\x43\xac\xb0\x69\x88\x23\xb4\x83\x74\xb6\x8a\x7b\x07\xec\x72\xfd\x64\x84\x80\x6c\x64\x08\xb0\x66\x85\x9c\x06\x3b\xa3\xd2\xa5\x0e\xc8\x55\x35\xf5\xde\x1a\xe5\x62\x1a\x63\x61\x47\xc3\x24\x35\xf6\x14\x82\x91\x87\x8f\x34\x49\x7a\x9c\x44\x92\xfb\xca\x24\x97\x6e\xed\x68\xeb\x0e\x49\xdc\x35\xfb\x9c\xdf\x6a\x3a\x6c\xff\xf5\x0a\x77\x72\x2e\x96\x26\x8a\x66\x4e\x49\x34\x1c\x62\x81\xbd\x9c\x0a\x91\x38\x3d\xb8\x1a\x58\x3e\x3d\x5f\x2f\xd2\xfd\xcf\x44\x7b\xae\x0a\x4c\xad\x7c\x7a\xba\x51\x03\xe8\x6a\x4a\xaf\x94\xc4\x64\x3a\xf8\x32\x60\xe1\x33\xd5\x6a\x09\xfc\xa0\xdf\x2f\xae\x3e\x5c\xec\xbf\x0d\x6f\x68\xeb\x2e\x34\x93\x7f\xfb\x36\xfc\xf0\x77\x00\x00\x00\xff\xff\x22\x0d\xa1\x4e\x40\x0a\x00\x00")

func db_sqlite_migrations_metadata_1637447083_sql() ([]byte, error) {
	return bindata_read(
		_db_sqlite_migrations_metadata_1637447083_sql,
		"../../../db/sqlite/migrations/metadata/1637447083.sql",
	)
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		return f()
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() ([]byte, error){
	"../../../db/sqlite/migrations/metadata/1637447083.sql": db_sqlite_migrations_metadata_1637447083_sql,
}
// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for name := range node.Children {
		rv = append(rv, name)
	}
	return rv, nil
}

type _bintree_t struct {
	Func func() ([]byte, error)
	Children map[string]*_bintree_t
}
var _bintree = &_bintree_t{nil, map[string]*_bintree_t{
	"..": &_bintree_t{nil, map[string]*_bintree_t{
		"..": &_bintree_t{nil, map[string]*_bintree_t{
			"..": &_bintree_t{nil, map[string]*_bintree_t{
				"db": &_bintree_t{nil, map[string]*_bintree_t{
					"sqlite": &_bintree_t{nil, map[string]*_bintree_t{
						"migrations": &_bintree_t{nil, map[string]*_bintree_t{
							"metadata": &_bintree_t{nil, map[string]*_bintree_t{
								"1637447083.sql": &_bintree_t{db_sqlite_migrations_metadata_1637447083_sql, map[string]*_bintree_t{
								}},
							}},
						}},
					}},
				}},
			}},
		}},
	}},
}}
